from aiogram import Bot, Dispatcher, types
from aiogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.utils import executor
from aiogram.contrib.middlewares.logging import LoggingMiddleware
import sqlite3
from datetime import datetime, timedelta
import logging
import os

API_TOKEN = os.getenv("BOT_TOKEN")  # Ð’ÑÑ‚Ð°Ð²ÑŒ ÑÐ²Ð¾Ð¹ Ñ‚Ð¾ÐºÐµÐ½ ÑÑŽÐ´Ð° Ð¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ

logging.basicConfig(level=logging.INFO)

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)
dp.middleware.setup(LoggingMiddleware())

# Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
conn = sqlite3.connect('messages.db')
cursor = conn.cursor()
cursor.execute('''
    CREATE TABLE IF NOT EXISTS messages_log (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        chat_id INTEGER,
        user_id INTEGER,
        username TEXT,
        timestamp TEXT
    )
''')
conn.commit()

# Ð¥ÐµÐ½Ð´Ð»ÐµÑ€ Ð½Ð° Ð»ÑŽÐ±Ð¾Ðµ Ð²Ñ…Ð¾Ð´ÑÑ‰ÐµÐµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð² Ð³Ñ€ÑƒÐ¿Ð¿Ðµ
@dp.message_handler(content_types=types.ContentTypes.TEXT)
async def count_messages(message: Message):
    if message.chat.type not in ['group', 'supergroup']:
        return

    chat_id = message.chat.id
    user_id = message.from_user.id
    username = message.from_user.username or message.from_user.full_name
    timestamp = datetime.utcnow().isoformat()

    cursor.execute('''
        INSERT INTO messages_log (chat_id, user_id, username, timestamp)
        VALUES (?, ?, ?, ?)
    ''', (chat_id, user_id, username, timestamp))
    conn.commit()

# ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° /stats Ð¾Ñ‚ÐºÑ€Ñ‹Ð²Ð°ÐµÑ‚ ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñƒ Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð¾Ð¼ Ð¿ÐµÑ€Ð¸Ð¾Ð´Ð°
@dp.message_handler(commands=['stats'])
async def show_period_options(message: Message):
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("1 Ð´ÐµÐ½ÑŒ", callback_data="stats_1d"),
        InlineKeyboardButton("7 Ð´Ð½ÐµÐ¹", callback_data="stats_7d"),
        InlineKeyboardButton("30 Ð´Ð½ÐµÐ¹", callback_data="stats_30d"),
        InlineKeyboardButton("Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð´Ð°Ñ‚Ñ‹", callback_data="stats_custom")
    )
    await message.reply("Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ð¿ÐµÑ€Ð¸Ð¾Ð´ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ¸:", reply_markup=keyboard)

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐºÐ½Ð¾Ð¿Ð¾Ðº Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´Ð°
@dp.callback_query_handler(lambda c: c.data.startswith('stats_'))
async def process_stats_callback(callback_query: CallbackQuery):
    data = callback_query.data
    chat_id = callback_query.message.chat.id

    if data == 'stats_custom':
        await bot.send_message(chat_id, "ÐžÑ‚Ð¿Ñ€Ð°Ð²ÑŒ Ð´Ð°Ñ‚Ñ‹ Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ: \n`2024-05-01 2024-05-10`", parse_mode='Markdown')
        return

    days = int(data.replace('stats_', '').replace('d', ''))
    since = datetime.utcnow() - timedelta(days=days)

    cursor.execute('''
        SELECT username, COUNT(*) as msg_count FROM messages_log
        WHERE chat_id = ? AND timestamp >= ?
        GROUP BY user_id ORDER BY msg_count DESC LIMIT 10
    ''', (chat_id, since.isoformat()))

    rows = cursor.fetchall()
    if not rows:
        await bot.send_message(chat_id, "ÐÐµÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð·Ð° Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´.")
        return

    response = f"ðŸ“Š Ð¡Ð¢ÐÐ¢Ð˜Ð¡Ð¢Ð˜ÐšÐ Ð¡ÐžÐžÐ‘Ð©Ð•ÐÐ˜Ð™ Ð—Ð ÐŸÐžÐ¡Ð›Ð•Ð”ÐÐ˜Ð• {days} Ð”ÐÐ•Ð™

"
    for username, count in rows:
        response += f"{username} - {count} ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
"

    await bot.send_message(chat_id, response)

# ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¾Ð³Ð¾ Ð²Ð²Ð¾Ð´Ð° Ð´Ð»Ñ Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ð° Ð´Ð°Ñ‚
@dp.message_handler(lambda message: len(message.text.split()) == 2)
async def custom_date_stats(message: Message):
    try:
        date_from_str, date_to_str = message.text.split()
        date_from = datetime.strptime(date_from_str, "%Y-%m-%d")
        date_to = datetime.strptime(date_to_str, "%Y-%m-%d") + timedelta(days=1)
    except ValueError:
        await message.reply("ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ Ð´Ð°Ñ‚. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚: 2024-05-01 2024-05-10")
        return

    cursor.execute('''
        SELECT username, COUNT(*) as msg_count FROM messages_log
        WHERE chat_id = ? AND timestamp >= ? AND timestamp < ?
        GROUP BY user_id ORDER BY msg_count DESC LIMIT 10
    ''', (message.chat.id, date_from.isoformat(), date_to.isoformat()))

    rows = cursor.fetchall()
    if not rows:
        await message.reply("ÐÐµÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð·Ð° ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ñ‹Ð¹ Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½ Ð´Ð°Ñ‚.")
        return

    response = f"ðŸ“Š Ð¡Ð¢ÐÐ¢Ð˜Ð¡Ð¢Ð˜ÐšÐ Ð¡ÐžÐžÐ‘Ð©Ð•ÐÐ˜Ð™ Ð¡ {date_from_str} ÐŸÐž {date_to_str[:-3]}

"
    for username, count in rows:
        response += f"{username} - {count} ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
"

    await message.reply(response)

if __name__ == '__main__':
    executor.start_polling(dp, skip_updates=True)
